name: Production Deployment Pipeline

on:
  push:
    branches: [main]
    tags: ['v*']
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  PYTHON_VERSION: '3.10'
  TERRAFORM_VERSION: '1.6.0'
  HELM_VERSION: 'v3.13.0'
  KUBECTL_VERSION: 'v1.28.0'

permissions:
  contents: read
  packages: write
  id-token: write
  security-events: write
  actions: read

jobs:
  # Pre-deployment validation
  pre-deployment:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.determine-env.outputs.environment }}
      should_deploy: ${{ steps.determine-env.outputs.should_deploy }}
      image_tag: ${{ steps.determine-env.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine deployment environment
        id: determine-env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ inputs.environment }}"
          elif [[ "${{ github.ref }}" =~ ^refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            ENVIRONMENT="production"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="staging"
          else
            ENVIRONMENT="development"
          fi
          
          # Determine image tag
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            IMAGE_TAG="${{ github.ref_name }}"
          else
            IMAGE_TAG="${{ github.sha }}"
          fi
          
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          
          echo "Deployment environment: ${ENVIRONMENT}"
          echo "Image tag: ${IMAGE_TAG}"

  # Security and quality checks
  security-checks:
    name: Security & Quality Checks
    runs-on: ubuntu-latest
    needs: pre-deployment
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt -r requirements-dev.txt

      - name: Run security scan
        run: |
          bandit -r src/ -f json -o bandit-report.json
          safety check --json --output safety-report.json

      - name: Run code quality checks
        run: |
          black --check src/
          isort --check-only src/
          flake8 src/
          mypy src/

      - name: Upload security artifacts
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: security-reports
          path: |
            bandit-report.json
            safety-report.json

  # Build and test
  build-test:
    name: Build & Test
    runs-on: ubuntu-latest
    needs: [pre-deployment, security-checks]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt -r requirements-dev.txt
          pip install -e .

      - name: Run tests
        run: |
          pytest tests/ -v --cov=gaudi3_scale --cov-report=xml --cov-report=html --junitxml=junit.xml

      - name: Upload test results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results
          path: |
            junit.xml
            htmlcov/
            coverage.xml

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
          fail_ci_if_error: true

  # Container build and scan
  container-build:
    name: Container Build & Security Scan
    runs-on: ubuntu-latest
    needs: [build-test]
    outputs:
      image: ${{ steps.build.outputs.image }}
      digest: ${{ steps.build.outputs.digest }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.production
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VCS_REF=${{ github.sha }}
            VERSION=${{ needs.pre-deployment.outputs.image_tag }}

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.pre-deployment.outputs.image_tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Infrastructure deployment
  infrastructure-deploy:
    name: Infrastructure Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment, container-build]
    environment: ${{ needs.pre-deployment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Init
        working-directory: deployment/terraform/environments/${{ needs.pre-deployment.outputs.environment }}
        run: terraform init

      - name: Terraform Plan
        working-directory: deployment/terraform/environments/${{ needs.pre-deployment.outputs.environment }}
        run: |
          terraform plan -var="image_tag=${{ needs.pre-deployment.outputs.image_tag }}" \
                         -out=tfplan

      - name: Terraform Apply
        working-directory: deployment/terraform/environments/${{ needs.pre-deployment.outputs.environment }}
        run: terraform apply tfplan

      - name: Get cluster credentials
        run: |
          aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} \
                                   --name gaudi3-scale-${{ needs.pre-deployment.outputs.environment }}

  # Application deployment
  application-deploy:
    name: Application Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment, container-build, infrastructure-deploy]
    environment: ${{ needs.pre-deployment.outputs.environment }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Get cluster credentials
        run: |
          aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} \
                                   --name gaudi3-scale-${{ needs.pre-deployment.outputs.environment }}

      - name: Create namespace if not exists
        run: |
          kubectl create namespace gaudi3-scale --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy secrets
        run: |
          # Create secrets from GitHub secrets
          kubectl create secret generic gaudi3-scale-secrets \
            --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL }}" \
            --from-literal=REDIS_URL="${{ secrets.REDIS_URL }}" \
            --from-literal=SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            --from-literal=JWT_SECRET="${{ secrets.JWT_SECRET }}" \
            --from-literal=WANDB_API_KEY="${{ secrets.WANDB_API_KEY }}" \
            --namespace=gaudi3-scale \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy with Helm
        run: |
          helm upgrade --install gaudi3-scale deployment/helm/gaudi3-scale \
            --namespace gaudi3-scale \
            --set image.tag=${{ needs.pre-deployment.outputs.image_tag }} \
            --set app.environment=${{ needs.pre-deployment.outputs.environment }} \
            --set api.ingress.enabled=true \
            --set api.ingress.hosts[0].host=api-${{ needs.pre-deployment.outputs.environment }}.gaudi3-scale.com \
            --set monitoring.enabled=true \
            --values deployment/helm/gaudi3-scale/values-${{ needs.pre-deployment.outputs.environment }}.yaml \
            --wait --timeout=600s

      - name: Verify deployment
        run: |
          kubectl rollout status deployment/gaudi3-scale-api -n gaudi3-scale --timeout=300s
          kubectl get pods -n gaudi3-scale
          kubectl get services -n gaudi3-scale

  # Smoke tests
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: [pre-deployment, application-deploy]
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Get cluster credentials
        run: |
          aws eks update-kubeconfig --region ${{ vars.AWS_REGION }} \
                                   --name gaudi3-scale-${{ needs.pre-deployment.outputs.environment }}

      - name: Run smoke tests
        run: |
          # Port forward to access the API
          kubectl port-forward service/gaudi3-scale-api 8080:80 -n gaudi3-scale &
          PF_PID=$!
          sleep 10
          
          # Run basic health checks
          curl -f http://localhost:8080/health || exit 1
          curl -f http://localhost:8080/health/ready || exit 1
          curl -f http://localhost:8080/ || exit 1
          
          # Kill port forward
          kill $PF_PID

  # Performance tests (production only)
  performance-tests:
    name: Performance Tests
    runs-on: ubuntu-latest
    needs: [pre-deployment, smoke-tests]
    if: needs.pre-deployment.outputs.environment == 'production'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install load testing tools
        run: |
          pip install locust pytest-benchmark

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Run performance tests
        run: |
          # Get API endpoint
          API_ENDPOINT=$(aws eks describe-cluster --name gaudi3-scale-production --region ${{ vars.AWS_REGION }} --query 'cluster.endpoint' --output text)
          
          # Run load tests
          locust --headless --users 100 --spawn-rate 10 --run-time 5m \
                 --host=${API_ENDPOINT} \
                 -f tests/performance/locustfile.py \
                 --html performance-report.html

      - name: Upload performance results
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: performance-results
          path: performance-report.html

  # Deployment notification
  notify-deployment:
    name: Deployment Notification
    runs-on: ubuntu-latest
    needs: [pre-deployment, smoke-tests, performance-tests]
    if: always()
    steps:
      - name: Notify Slack on success
        if: needs.smoke-tests.result == 'success' && (needs.performance-tests.result == 'success' || needs.performance-tests.result == 'skipped')
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          message: |
            ✅ Gaudi 3 Scale successfully deployed to ${{ needs.pre-deployment.outputs.environment }}
            Environment: ${{ needs.pre-deployment.outputs.environment }}
            Image: ${{ needs.container-build.outputs.image }}
            Commit: ${{ github.sha }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: Notify Slack on failure
        if: failure()
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          message: |
            ❌ Gaudi 3 Scale deployment failed for ${{ needs.pre-deployment.outputs.environment }}
            Environment: ${{ needs.pre-deployment.outputs.environment }}
            Commit: ${{ github.sha }}
            Check the logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}